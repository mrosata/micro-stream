{"version":3,"file":null,"sources":["../src/utils.js","../src/stream.class.js","../src/index.js"],"sourcesContent":["\"use strict\";\n/**\n * Utilities used in through the Stream classes.\n */\nconst id = x => x;\nconst is = fn => thing => !!fn(thing);\nconst isNot = fn => thing => !fn(thing);\nconst isSomething = thing => typeof thing !== 'undefined' && thing !== null;\nconst isFunction = thing => typeof thing === 'function';\nconst isObject = thing => !!thing && typeof thing === \"object\";\nconst isArray = Array.isArray;\nconst inspect = (item) => item && isFunction(item.inspect) ? item.inspect() : item;\n\n/**\n *  This is temporary. Originally there were functional compositions with monads\n *  in the original Micro-Stream class handling IO. However, Micro-Stream shouldn't\n *  make assumptions about code. I don't want to import the monads required. So\n *  for now, this will be the way to implement these DOM IO ops.\n */\nconst docQueryHookEvent = (eventType, hook, selector ) => {\n  const elem = document.querySelector(selector);\n  if (elem) {\n    elem.addEventListener(eventType, hook, false);\n  }\n  else {\n    hook(\n      new Error(\n        `Unable to hook event to selector: ${selector}; element: ${typeof elem}`))\n  }\n};\n\n\nfunction path(pathOfProps) {\n  pathOfProps = [].concat(pathOfProps);\n  \n  return function(obj) {\n    return pathOfProps.reduce((accum, propName) => {\n      return isObject(accum) ? accum[propName] : undefined;\n    }, obj);\n  }\n}\n\n\nfunction getCopy(subject) {\n  if (isObject(subject)) {\n    // Arrays\n    if (isArray(subject)) {\n      let items = [];\n      for (let item in subject) {\n        subject[subject.length - 1] = getCopy(item);\n      }\n      return items;\n    }\n    \n    // Dates\n    if (subject.constructor === Date) {\n      return new Date(subject.toISOString());\n    }\n    \n    // Regular Objects\n    return Object.assign({}, subject);\n  }\n  \n  // Everything Else\n  return subject;\n}\n\nexport {\n  path, id, is, isNot, isSomething, isFunction, isObject, inspect, docQueryHookEvent, getCopy\n}\n","\"use strict\";\n/*\n * @package Micro Stream\n */\nimport {\n  docQueryHookEvent, inspect, id, isSomething, isObject, isFunction, getCopy, path\n} from \"./utils.js\";\n\n\nconst STREAM = 0;\nconst STREAM_OBSERVER = 1;\nconst STREAM_REDUCER = 2;\nconst STREAM_TYPE = ['Stream', 'StreamObserver', 'StreamReducer'];\n\nexport default class Stream {\n  /**\n   * @constructor Stream\n   */\n  constructor() {\n    this.__type = STREAM;\n    this.__value = (x)=>x;\n    this.__cancelled = false;\n    this.observers = [];\n  }\n  \n  /**\n   * Create a new stream\n   *\n   * @param emitter {Function|void}\n   * @returns {Stream}\n   */\n  static of(emitter) {\n    const stream = new Stream();\n    if (typeof emitter === \"function\") {\n      emitter(stream.push.bind(stream));\n    }\n    return stream;\n  }\n  \n  static fromEvent(eventType, selector = 'body') {\n    return Stream.of((hook) => {\n      return docQueryHookEvent(eventType, hook, selector)\n    })\n  }\n  \n  \n  /**\n   * @param fn\n   * @returns {Stream}\n   */\n  map(fn) {\n    const __value = this.__value.bind(this);\n    // The only time we don't auto subscribe is on a main Stream.\n    if (this.__type !== STREAM) {\n      let obs = new StreamObserver(this.cancel.bind(this), (data) => fn(__value(data)));\n      this.observers.push(obs);\n      return obs.subscribe;\n    }\n    // If this is a root STREAM, then we actually mutate its inner value. Keep the stream mega lazy.\n    this.__value = (data) => fn(__value(data));\n    return this;\n  }\n  \n  /**\n   * Run a function as if doing a `map`, but the function has\n   * no effect over the return value of the stream.\n   *\n   * @param fn\n   */\n  tap(fn) {\n    return this.map((val) => {\n      fn(val);\n      return val;\n    });\n  }\n  \n  as(value) {\n    return this.map(() => value);\n  }\n  \n  /**\n   * Map with additional error handling.\n   * @param fn\n   * @param errorHandler\n   * @returns {Stream}\n   */\n  trap(fn, errorHandler = id) {\n    return this.map((val) => {\n      try {\n        return fn(val);\n      }\n      catch (err) {\n        return errorHandler(err);\n      }\n    });\n  }\n  \n  /**\n   * Safely resolve path values on an object. Returns those values to the\n   * next function downstream or undefined, but it won't throw if the\n   * properties don't exist on the object.\n   * @param arrayResolvingPath\n   * @returns {*}\n   */\n  path(arrayResolvingPath) {\n    return this.map(path(arrayResolvingPath))\n  }\n  \n  get subscribe() {\n    return this.__subscribe();\n  }\n  set subscribe(fn) {\n    return this.__subscribe(fn);\n  }\n  \n  \n  /**\n   * The main entry point for data being observed. When the stream\n   * emits new data, it pushes it through this method.\n   * @param data {*}\n   */\n  push(data) {\n    if (!this.__cancelled && this.observers.length > 0) {\n      const _data = this.__value(data);\n      this.observers.map(obs => obs.push(_data));\n    }\n    return this;\n  }\n  \n  \n  /**\n   * Cancels any observers which in turn cancels any of their observers,\n   * finally calls any Stream which it may be observing.\n   *\n   * @returns {Stream}\n   */\n  cancel() {\n    if (this.__cancelled) {\n      throw `Cancelled ${STREAM_TYPE[this.__type]} cannot cancel other streams!`;\n    }\n    // Cancel any streams which depend on this stream for data.\n    this.observers.map(obs => {\n      obs.cancel.call(obs);\n    });\n    // Cancel this stream as well.\n    this.__cancelled = true;\n    return this;\n  }\n  \n  \n  /**\n   * Subscribe a specific stream type to `this` Stream. Optionally pass in a function to act\n   * as the first \"listener\" in the stream.\n   *\n   * @param baseFn\n   * @returns {StreamObserver}\n   * @private\n   */\n  __subscribe( baseFn = id) {\n    const obs = new StreamObserver(this.cancel.bind(this), baseFn);\n    this.observers.push(obs);\n    return obs;\n  }\n  \n  /**\n   * Inspect a Stream\n   * @returns {string}\n   */\n  inspect() {\n    return `${STREAM_TYPE[this.__type]}( ${ inspect(this.__value) } )`;\n  }\n  \n}\n\n\n\nclass StreamObserver extends Stream {\n  \n  static of(stream, baseObservation) {\n    if (!isObject(stream) || stream.constructor !== Stream) {\n      throw `Argument 1 to StreamObserver.of must be Stream. Received ${stream}`;\n    }\n    return new StreamObserver(stream.cancel.bind(stream), baseObservation);\n  }\n  /**\n   * @param cancelStream {Function}\n   * @param baseObservation {Function|void}\n   */\n  constructor(cancelStream, baseObservation) {\n    super(baseObservation);\n    this.__type = STREAM_OBSERVER;\n    this.observers = [];\n    this.cancelStream = cancelStream;\n    this.__value = baseObservation.bind(this);\n    this.__cancelled = false;\n  }\n  \n  \n  /**\n   * This method will remove the need for developers to \"curry\" their own functions.\n   *\n   * @param baseFn {Function}\n   */\n  curry(baseFn) {\n    const recursiveCase = isFunction;\n    const accumulator = (fn, arg) => {\n      if (fn.length <= 1) {\n        return fn(arg);\n      }\n      return fn.bind(fn, arg);\n    };\n    \n    \n    const  cancelFn = this.cancel.bind(this);\n    const streamObserver = new StreamReducer(\n      cancelFn, accumulator, recursiveCase, baseFn);\n    \n    this.observers.push(streamObserver);\n    return streamObserver;\n  }\n  \n  \n  /**\n   * For yielding til all parameters of a curried function are filled.\n   *\n   * @desc pipe stream into an already curried function implementation.\n   * @param baseFn {Function} An already curried function\n   * @returns {StreamObserver}\n   */\n  curried(baseFn) {\n    const recursiveCase = isFunction;\n    const accumulator = (fn, arg) => fn.call(fn, arg);\n    \n    const  cancelFn = this.cancel.bind(this);\n    const streamObserver = new StreamReducer(\n      cancelFn, accumulator, recursiveCase, baseFn);\n    \n    this.observers.push(streamObserver);\n    return streamObserver;\n  }\n  \n  \n  \n  /**\n   * Filter out values in a stream.\n   *\n   * The filter method returns a new instance of an StreamReducer. It uses\n   * the op passed in as `fiterFn` as an accumulator so that only values which meet\n   * that filter test are returned from the reducer and passed down the stream.\n   * @param filterFn\n   */\n  filter(filterFn = isSomething) {\n    const accumulator = (accum, item) => item;\n    const recursiveCase = (val) => !filterFn(val);\n    const streamObserver = new StreamReducer(\n      this.cancel.bind(this), accumulator, recursiveCase, null);\n    \n    this.observers.push(streamObserver);\n    return streamObserver;\n  }\n  \n  \n  reduce(accumulator, defaultValue = null, recursiveCase) {\n    let observer, _recursiveCase, reducer;\n    \n    if (!isFunction(recursiveCase)) {\n      // This is going to do infinite folding, which means we will need a way\n      // to get the values out from iterator without actually completing it.\n      // So we'll create a new observer to receive each value everytime the\n      // generator is ran.\n      observer = new StreamObserver(this.cancel.bind(this), id);\n      _recursiveCase = (data) => {observer.push(data); return true;};\n      \n      reducer = new StreamReducer(\n        this.cancel.bind(this), accumulator, _recursiveCase, defaultValue);\n    }\n    else {\n      // The other case (recursiveCase was defined by developer as a function),\n      // The reducer and the observer are the same thing, once the generator\n      // completes it will push the reduced value out and start again.\n      reducer = observer = new StreamReducer(\n        this.cancel.bind(this), accumulator, recursiveCase, defaultValue);\n    }\n    \n    this.observers.push(reducer);\n    return observer;\n  }\n  \n  \n  \n  /**\n   * Pass a function that returns a promise into the StreamObserver and also\n   * an optional error handler. The rejectionHandler allows the developer to fix\n   * a bad value just like with trap. So if the promise is rejected then it will\n   * be passed to rejectionHandler and the value returned from there will be\n   * the value passed down the stream.\n   *\n   * @param promiseFactory {Function}\n   * @param rejectionHandler {Function|void}\n   * @returns {StreamObserver}\n   */\n  async(promiseFactory, rejectionHandler = id) {\n    const observer = new StreamObserver(this.cancel.bind(this), id);\n    const reducer = new StreamReducer(\n      () => {\n        // Since we \"thread the loop\" here, we have 2 cancellations.\n        observer.cancel.bind(observer);\n        // cancel this\n        this.cancel.bind(this);\n      },\n      (_, item) => {\n        const promise = promiseFactory(item);\n        promise\n          .then(id)\n          .catch(rejectionHandler)\n          .then(observer.push.bind(observer));\n        return promise;\n      }, () => true);\n    \n    this.observers.push(reducer);\n    return observer;\n  }\n  \n}\n\n\n\nclass StreamReducer extends StreamObserver {\n  \n  \n  static of(accumulator, recursiveCase, defaultValue) {\n    return new StreamReducer(null, accumulator, recursiveCase, defaultValue);\n  }\n  \n  \n  constructor(cancelStream, accumulator, recursiveCase, baseValue = []) {\n    baseValue = isObject(baseValue) ? getCopy(baseValue) : baseValue;\n    super(cancelStream, id);\n    this.observers = [];\n    this.__type = STREAM_REDUCER;\n    this.__accumulator = accumulator;\n    this.__recursiveCase = recursiveCase;\n    this.__baseValue = baseValue;\n    this.prepareIterator();\n  }\n  \n  \n  /**\n   * Prepare an iterator which accepts the streams output as the\n   * next param to a accumulators input. Once the `accumulator(input)`\n   * is able to meet the `recursiveCase` then the iterator completes\n   * and returns the reduction of all accumulated inputs thus far and\n   * the process starts over upon the next input value from stream.\n   */\n  prepareIterator() {\n    let recursiveCase = isFunction( this.__recursiveCase) ? this.__recursiveCase : ()=>false;\n    let accumulator = this.__accumulator;\n    \n    const generator = function * accumulateTilRecursiveCase(baseValue) {\n      let value = baseValue;\n      while (recursiveCase(value)) {\n        value = accumulator(value, yield);\n      }\n      \n      return value;\n    };\n    \n    // Get the generator setup for first streamed event\n    this.__iterator = generator(getCopy(this.__baseValue));\n    this.__iterator.next(); // first call won't set `data`\n  }\n  \n  \n  /**\n   * StreamReducers override the super method `push` in order\n   * to \"hold back\" the __value until all of its params are full.\n   *\n   * @param data {*}\n   */\n  push(data) {\n    let __value = this.__value = this.__iterator.next(data);\n    \n    if (__value.done && !this.__cancelled) {\n      this.observers.map(obs => obs.push(__value.value));\n      this.prepareIterator();\n    }\n    return this;\n  }\n  \n}\n\n\nexport {\n  Stream, StreamObserver, StreamReducer\n}","\"use strict\";\n/*\n * @package MicroStreamJS (micro-stream)\n */\n\nimport { Stream, StreamObserver, StreamReducer } from './stream.class.js'\n\n// Export main class Stream and a helper for inspections.\nexport { Stream, StreamObserver, StreamReducer };\n"],"names":["id","x","isSomething","thing","isFunction","isObject","isArray","Array","inspect","item","docQueryHookEvent","eventType","hook","selector","elem","document","querySelector","addEventListener","Error","path","pathOfProps","concat","obj","reduce","accum","propName","undefined","getCopy","subject","items","length","constructor","Date","toISOString","STREAM","STREAM_OBSERVER","STREAM_REDUCER","STREAM_TYPE","Stream","__type","__value","__cancelled","observers","fn","bind","obs","StreamObserver","cancel","data","push","subscribe","map","val","value","errorHandler","err","arrayResolvingPath","_data","call","baseFn","__subscribe","emitter","stream","of","baseObservation","cancelStream","recursiveCase","accumulator","arg","cancelFn","streamObserver","StreamReducer","filterFn","defaultValue","observer","_recursiveCase","reducer","promiseFactory","rejectionHandler","_","promise","then","catch","baseValue","__accumulator","__recursiveCase","__baseValue","prepareIterator","generator","accumulateTilRecursiveCase","__iterator","next","done"],"mappings":"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"}