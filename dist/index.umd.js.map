{"version":3,"file":null,"sources":["../src/utils.js","../src/stream.class.js","../src/index.js"],"sourcesContent":["\"use strict\";\n/**\n * Utilities used in through the Stream classes.\n */\nconst id = x => x;\nconst is = fn => thing => !!fn(thing);\nconst isNot = fn => thing => !fn(thing);\nconst isSomething = thing => typeof thing !== 'undefined' && thing !== null;\nconst isFunction = thing => typeof thing === 'function';\nconst isObject = thing => !!thing && typeof thing === \"object\";\nconst isArray = Array.isArray;\nconst inspect = (item) => item && isFunction(item.inspect) ? item.inspect() : item;\n\n/**\n *  This is temporary. Originally there were functional compositions with monads\n *  in the original Micro-Stream class handling IO. However, Micro-Stream shouldn't\n *  make assumptions about code. I don't want to import the monads required. So\n *  for now, this will be the way to implement these DOM IO ops.\n */\nconst docQueryHookEvent = (eventType, hook, selector ) => {\n  const elem = document.querySelector(selector);\n  if (elem) {\n    elem.addEventListener(eventType, hook, false);\n  }\n  else {\n    hook(\n      new Error(\n        `Unable to hook event to selector: ${selector}; element: ${typeof elem}`))\n  }\n};\n\n\nfunction path(pathOfProps) {\n  pathOfProps = [].concat(pathOfProps);\n\n  return function(obj) {\n    return pathOfProps.reduce((accum, propName) => {\n      return isObject(accum) ? accum[propName] : undefined;\n    }, obj);\n  }\n}\n\n\nfunction getCopy(subject) {\n  if (isObject(subject)) {\n    // Arrays\n    if (isArray(subject)) {\n      let items = [];\n      for (let item in subject) {\n        subject[subject.length - 1] = getCopy(item);\n      }\n      return items;\n    }\n\n    // Dates\n    if (subject.constructor === Date) {\n      return new Date(subject.toISOString());\n    }\n\n    // Regular Objects\n    return Object.assign({}, subject);\n  }\n\n  // Everything Else\n  return subject;\n}\n\n\nfunction assert (assert, message) {\n  if (!assert) {\n    throw new Error(message);\n  }\n}\n\nfunction assertIsGenerator(testValue, msg='was expecting generator') {\n  return assert(\n    typeof testValue === \"function\" &&\n    testValue.constructor.toString().match(/generatorfunction/i),\n    msg\n  );\n}\n\nfunction assertIsNumber(testValue, msg='was expecting number') {\n  return assert(\n    typeof testValue === \"number\" && testValue > 0,\n    msg\n  );\n}\n\nfunction size (list) {\n  return !list ? 0 : list.length;\n}\n\n\nexport {\n  path, id, is, isNot, isSomething, isFunction, isObject, inspect, docQueryHookEvent, getCopy, assert, assertIsNumber, assertIsGenerator, size\n}\n","\"use strict\";\n/*\n * @package Micro Stream\n */\nimport {\n  docQueryHookEvent, inspect, id, isSomething, isObject, isFunction, getCopy, path\n} from \"./utils.js\";\n\n\nconst STREAM = 0;\nconst STREAM_OBSERVER = 1;\nconst STREAM_REDUCER = 2;\nconst STREAM_TYPE = ['Stream', 'StreamObserver', 'StreamReducer'];\n\nexport default class Stream {\n  /**\n   * @constructor Stream\n   */\n  constructor() {\n    this.__type = STREAM;\n    this.__value = (x)=>x;\n    this.__cancelled = false;\n    this.observers = [];\n  }\n  \n  /**\n   * Create a new stream\n   *\n   * @param emitter {Function|void}\n   * @returns {Stream}\n   */\n  static of(emitter) {\n    const stream = new Stream();\n    if (typeof emitter === \"function\") {\n      emitter(stream.push.bind(stream));\n    }\n    return stream;\n  }\n  \n  static fromEvent(eventType, selector = 'body') {\n    return Stream.of((hook) => {\n      return docQueryHookEvent(eventType, hook, selector)\n    })\n  }\n  \n  \n  /**\n   * @param fn\n   * @returns {Stream}\n   */\n  map(fn) {\n    const __value = this.__value.bind(this);\n    // The only time we don't auto subscribe is on a main Stream.\n    if (this.__type !== STREAM) {\n      let obs = new StreamObserver(this.cancel.bind(this), (data) => fn(__value(data)));\n      this.observers.push(obs);\n      return obs.subscribe;\n    }\n    // If this is a root STREAM, then we actually mutate its inner value. Keep the stream mega lazy.\n    this.__value = (data) => fn(__value(data));\n    return this;\n  }\n  \n  /**\n   * Run a function as if doing a `map`, but the function has\n   * no effect over the return value of the stream.\n   *\n   * @param fn\n   */\n  tap(fn) {\n    return this.map((val) => {\n      fn(val);\n      return val;\n    });\n  }\n  \n  as(value) {\n    return this.map(() => value);\n  }\n  \n  /**\n   * Map with additional error handling.\n   * @param fn\n   * @param errorHandler\n   * @returns {Stream}\n   */\n  trap(fn, errorHandler = id) {\n    return this.map((val) => {\n      try {\n        return fn(val);\n      }\n      catch (err) {\n        return errorHandler(err);\n      }\n    });\n  }\n  \n  /**\n   * Safely resolve path values on an object. Returns those values to the\n   * next function downstream or undefined, but it won't throw if the\n   * properties don't exist on the object.\n   * @param arrayResolvingPath\n   * @returns {*}\n   */\n  path(arrayResolvingPath) {\n    return this.map(path(arrayResolvingPath))\n  }\n  \n  get subscribe() {\n    return this.__subscribe();\n  }\n  set subscribe(fn) {\n    return this.__subscribe(fn);\n  }\n  \n  \n  /**\n   * The main entry point for data being observed. When the stream\n   * emits new data, it pushes it through this method.\n   * @param data {*}\n   */\n  push(data) {\n    if (!this.__cancelled && this.observers.length > 0) {\n      const _data = this.__value(data);\n      this.observers.map(obs => obs.push(_data));\n    }\n    return this;\n  }\n  \n  \n  /**\n   * Cancels any observers which in turn cancels any of their observers,\n   * finally calls any Stream which it may be observing.\n   *\n   * @returns {Stream}\n   */\n  cancel() {\n    if (this.__cancelled) {\n      throw `Cancelled ${STREAM_TYPE[this.__type]} cannot cancel other streams!`;\n    }\n    // Cancel any streams which depend on this stream for data.\n    this.observers.map(obs => {\n      obs.cancel.call(obs);\n    });\n    // Cancel this stream as well.\n    this.__cancelled = true;\n    return this;\n  }\n  \n  \n  /**\n   * Subscribe a specific stream type to `this` Stream. Optionally pass in a function to act\n   * as the first \"listener\" in the stream.\n   *\n   * @param baseFn\n   * @returns {StreamObserver}\n   * @private\n   */\n  __subscribe( baseFn = id) {\n    const obs = new StreamObserver(this.cancel.bind(this), baseFn);\n    this.observers.push(obs);\n    return obs;\n  }\n  \n  /**\n   * Inspect a Stream\n   * @returns {string}\n   */\n  inspect() {\n    return `${STREAM_TYPE[this.__type]}( ${ inspect(this.__value) } )`;\n  }\n  \n}\n\n\n\nclass StreamObserver extends Stream {\n  \n  static of(stream, baseObservation) {\n    if (!isObject(stream) || stream.constructor !== Stream) {\n      throw `Argument 1 to StreamObserver.of must be Stream. Received ${stream}`;\n    }\n    return new StreamObserver(stream.cancel.bind(stream), baseObservation);\n  }\n  /**\n   * @param cancelStream {Function}\n   * @param baseObservation {Function|void}\n   */\n  constructor(cancelStream, baseObservation) {\n    super(baseObservation);\n    this.__type = STREAM_OBSERVER;\n    this.observers = [];\n    this.cancelStream = cancelStream;\n    this.__value = baseObservation.bind(this);\n    this.__cancelled = false;\n  }\n  \n  \n  /**\n   * This method will remove the need for developers to \"curry\" their own functions.\n   *\n   * @param baseFn {Function}\n   */\n  curry(baseFn) {\n    const baseCase = test => !isFunction(test);\n    const accumulator = (fn, arg) => {\n      if (fn.length <= 1) {\n        return fn(arg);\n      }\n      return fn.bind(fn, arg);\n    };\n    \n    \n    const  cancelFn = this.cancel.bind(this);\n    const streamObserver = new StreamReducer(\n      cancelFn, accumulator, baseCase, baseFn);\n    \n    this.observers.push(streamObserver);\n    return streamObserver;\n  }\n  \n  \n  /**\n   * For yielding til all parameters of a curried function are filled.\n   *\n   * @desc pipe stream into an already curried function implementation.\n   * @param baseFn {Function} An already curried function\n   * @returns {StreamObserver}\n   */\n  curried(baseFn) {\n    const baseCase = test => !isFunction(test);\n    const accumulator = (fn, arg) => fn.call(fn, arg);\n    \n    const  cancelFn = this.cancel.bind(this);\n    const streamObserver = new StreamReducer(\n      cancelFn, accumulator, baseCase, baseFn);\n    \n    this.observers.push(streamObserver);\n    return streamObserver;\n  }\n  \n  \n  \n  /**\n   * Filter out values in a stream.\n   *\n   * The filter method returns a new instance of an StreamReducer. It uses\n   * the op passed in as `fiterFn` as an accumulator so that only values which meet\n   * that filter test are returned from the reducer and passed down the stream.\n   * @param filterFn\n   */\n  filter(filterFn = isSomething) {\n    const accumulator = (accum, item) => item;\n    const baseCase = (val) => filterFn(val);\n    const streamObserver = new StreamReducer(\n      this.cancel.bind(this), accumulator, baseCase, null);\n    \n    this.observers.push(streamObserver);\n    return streamObserver;\n  }\n  \n  \n  reduce(accumulator, defaultValue = null, baseCase) {\n    let observer, _baseCase, reducer;\n    \n    if (!isFunction(baseCase)) {\n      // This is going to do infinite folding, which means we will need a way\n      // to get the values out from iterator without actually completing it.\n      // So we'll create a new observer to receive each value everytime the\n      // generator is ran.\n      observer = new StreamObserver(this.cancel.bind(this), id);\n      _baseCase = (data) => {observer.push(data); return false;};\n      \n      reducer = new StreamReducer(\n        this.cancel.bind(this), accumulator, _baseCase, defaultValue);\n    }\n    else {\n      // The other case (baseCase was defined by developer as a function),\n      // The reducer and the observer are the same thing, once the generator\n      // completes it will push the reduced value out and start again.\n      reducer = observer = new StreamReducer(\n        this.cancel.bind(this), accumulator, baseCase, defaultValue);\n    }\n    \n    this.observers.push(reducer);\n    return observer;\n  }\n  \n  \n  \n  /**\n   * Pass a function that returns a promise into the StreamObserver and also\n   * an optional error handler. The rejectionHandler allows the developer to fix\n   * a bad value just like with trap. So if the promise is rejected then it will\n   * be passed to rejectionHandler and the value returned from there will be\n   * the value passed down the stream.\n   *\n   * @param promiseFactory {Function}\n   * @param rejectionHandler {Function|void}\n   * @returns {StreamObserver}\n   */\n  async(promiseFactory, rejectionHandler = id) {\n    const observer = new StreamObserver(this.cancel.bind(this), id);\n  \n    // Since we \"thread the loop\" here, we have 2 cancellations.\n    // cancel this\n    const cancellations = () => {\n      observer.cancel.bind(observer);\n      this.cancel.bind(this);\n    };\n    const reducer = new StreamReducer(\n      cancellations,\n      (_, item) => {\n        const promise = promiseFactory(item);\n        promise\n          .catch(rejectionHandler)\n          .then(observer.push.bind(observer));\n        return promise;\n      }, () => false); // ()=>false is baseCase (we want infinite loop)\n    \n    this.observers.push(reducer);\n    return observer;\n  }\n  \n}\n\n\n\nclass StreamReducer extends StreamObserver {\n  \n  \n  static of(accumulator, baseCase, defaultValue) {\n    return new StreamReducer(null, accumulator, baseCase, defaultValue);\n  }\n  \n  \n  /**\n   *\n   * @param cancelStream\n   * @param accumulator\n   * @param baseCase - recursive-case basically, but when true recursion stops\n   * @param baseValue\n   */\n  constructor(cancelStream, accumulator, baseCase, baseValue = []) {\n    baseValue = isObject(baseValue) ? getCopy(baseValue) : baseValue;\n    super(cancelStream, id);\n    this.observers = [];\n    this.__type = STREAM_REDUCER;\n    this.__accumulator = accumulator;\n    this.__baseCase = isFunction(baseCase) ? baseCase : ()=>true;\n    this.__baseValue = baseValue;\n    this.prepareIterator();\n  }\n  \n  \n  /**\n   * Prepare an iterator which accepts the streams output as the\n   * next param to a accumulators input. Once the `accumulator(input)`\n   * is able to meet the `baseCase` then the iterator completes\n   * and returns the reduction of all accumulated inputs thus far and\n   * the process starts over upon the next input value from stream.\n   */\n  prepareIterator() {\n    let baseCase = this.__baseCase;\n    let accumulator = this.__accumulator;\n    \n    const generator = function * accumulateTilRecursiveCase(baseValue) {\n      let value = baseValue;\n      while (!baseCase(value)) {\n        value = accumulator(value, yield);\n      }\n      \n      return value;\n    };\n    \n    // Get the generator setup for first streamed event\n    this.__iterator = generator(getCopy(this.__baseValue));\n    this.__iterator.next(); // first call won't set `data`\n  }\n  \n  \n  /**\n   * StreamReducers override the super method `push` in order\n   * to \"hold back\" the __value until all of its params are full.\n   *\n   * @param data {*}\n   */\n  push(data) {\n    let __value = this.__value = this.__iterator.next(data);\n    \n    if (__value.done && !this.__cancelled) {\n      this.observers.map(obs => obs.push(__value.value));\n      this.prepareIterator();\n    }\n    return this;\n  }\n  \n}\n\n\nexport {\n  Stream, StreamObserver, StreamReducer\n}\n","/*\n * @package MicroStreamJS (micro-stream)\n */\n'use strict';\n\nimport { Stream, StreamObserver, StreamReducer } from './stream.class.js'\n\n// Export main class Stream and a helper for inspections.\nexport { Stream, StreamObserver, StreamReducer };\n"],"names":["id","x","isSomething","thing","isFunction","isObject","isArray","Array","inspect","item","docQueryHookEvent","eventType","hook","selector","elem","document","querySelector","addEventListener","Error","path","pathOfProps","concat","obj","reduce","accum","propName","undefined","getCopy","subject","items","length","constructor","Date","toISOString","STREAM","STREAM_OBSERVER","STREAM_REDUCER","STREAM_TYPE","Stream","__type","__value","__cancelled","observers","fn","bind","obs","StreamObserver","cancel","data","push","subscribe","map","val","value","errorHandler","err","arrayResolvingPath","_data","call","baseFn","__subscribe","emitter","stream","of","baseObservation","cancelStream","baseCase","test","accumulator","arg","cancelFn","streamObserver","StreamReducer","filterFn","defaultValue","observer","_baseCase","reducer","promiseFactory","rejectionHandler","cancellations","_","promise","catch","then","baseValue","__accumulator","__baseCase","__baseValue","prepareIterator","generator","accumulateTilRecursiveCase","__iterator","next","done"],"mappings":"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"}